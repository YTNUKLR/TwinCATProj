<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="DMXTest" Id="{56d10ee8-0ed5-46cc-a7ec-34100a2134e6}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM DMXTest
VAR
	xStatTestInProgress			: BOOL;
	xDMXSeqTestInProgressOnce	: BOOL;
	xDMXSeqTestInProgressTwice	: BOOL;
	xDMXSeqTestInProgressOnceDC	: BOOL;
	uiCounter2					: UINT;
	uiCounter3					: UINT;
	uiCounter4					: UINT;
	uiCounter5					: UINT;
	uiCounter6					: UINT;
	uiCounter7					: UINT;
	uiCounter8					: UINT;
	uiCounter9					: UINT;
	uiDedicatedRcvdRTIndex		: UINT;
	uiContinuousRTIndex			: UINT;
	
	uiForLoopCfgIndex			: UINT;
//	uiForLoopCtrlWriteIndex		: UINT;
//	uiForLoopCtrlWriteIndex2	: UINT;	
	uiLoopExpctdIndex			: UINT;
	uiForLoopClearExpctd		: UINT;
	uiLoopRcvIndex				: UINT;
	uiByteIndex					: UINT;
	iForLoopRecipeFindMin		: INT;
	iForLoopRecipeFindMax		: INT;
	iForLoopRecipeFindMax1		: INT;
	iForLoopRecipeMin			: INT;
	uiForLoopRecipe				: UINT;

	
	iCompareStaticSM			: INT;
	iCompareSeq					: ARRAY[0..ENUM_SeqSM.Twice] OF INT;
	iParseFile					: INT;
	iSetConfig					: (Trig_SetConfigSM,ApplyRecipeCfgtoHW,ZeroIndexArrays,Set24VIndices,SetGNDIndices,SetDMXIndices,SetDCIndices,SetMPIndices,SetMSIndices,ConfigDone);
	iSetExpctdBufferSM			: INT;
	iReindexExpctedBufferSM		: INT;
	rt_RunStaticTest			: R_TRIG;
	rt_RunSeqTestOnce			: R_TRIG;
	rt_RunSeqTestOnceDC			: R_TRIG;
	rt_RunSeqTestTwice			: R_TRIG;
	rt_ResetTest				: R_TRIG;
	rt_ResetTestSeq				: R_TRIG;
	rt_ResetTestSeqDC			: R_TRIG;
	r_tStaticTestDone			: R_TRIG;
	
	//Arrays (Refactor 30-09-21)
	arr_uiRecipeIndexTmp		: ARRAY[0..gc.uiDUTConfigCountSplit] OF UINT;
 	arruiDMXChDUTTmp			: ARRAY[0..gc.uiDUTConfigCountSplit] OF UINT;
	arrsDUTChTypeTmp			: ARRAY[0..gc.uiDUTConfigCountSplit] OF STRING[3];	
	arr_uiRecipeIndex			: ARRAY[0..gc.uiDUTConfigCountSplit] OF UINT;
 	arruiDMXChDUT				: ARRAY[0..gc.uiDUTConfigCountSplit] OF UINT;
	arrsDUTChType				: ARRAY[0..gc.uiDUTConfigCountSplit] OF STRING[3];
	xFileImported				: BOOL;
	arr_usiRecipeSettingTmpRd1	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF USINT;
	arr_usiRecipeSettingTmpRd2	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF USINT;
	arr_usiRecipeSetting		: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF USINT;
	xRecipeSettingCompleteRd1	: BOOL;
	xRecipeSettingCompleteRd2	: BOOL;

	
	//Static
	arrxRcvdBufferPNP24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPN24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferPNPGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPNGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	
	//Sequenced
	arrxRcvdBufferPNPDC			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPNDC			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;	
	arrxRcvdBufferPNPDMX		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPNDMX		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	
	//Sequenced Motor
	arrxRcvdBufferPNPMP			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPNMP			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;	
	arrxRcvdBufferPNPMS			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxRcvdBufferNPNMS			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;

	//Static
	arrxExpctBufferPNP24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPN24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferPNPGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPNGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	
	//Sequenced
	arrxExpctBufferPNPDC		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPNDC		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;	
	arrxExpctBufferPNPDMX		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPNDMX		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	
	//Sequenced Motor
	arrxExpctBufferPNPMP		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPNMP		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;	
	arrxExpctBufferPNPMS		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	arrxExpctBufferNPNMS		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF BOOL;
	
	arrxExpctdMaskPNPSeq		: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF BOOL; //Copy the contents of hardware buffer 
	arrxExpctdMaskNPNSeq		: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF BOOL; //Copy the contents of hardware buffer
	
	arr_diTestStaticPNP24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestStaticNPN24V		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestStaticPNPGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestStaticNPNGND		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestPNPSeqOnceLine			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestPNPSeqOnceLineTmp			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestNPNSeqOnceLine			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestNPNSeqOnceLineTmp			: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;

	arr_udiMEMCPYPNPSeqOnceRcvdTmp		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UDINT;
	arr_udiMEMCPYNPNSeqOnceRcvdTmp		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UDINT;
			
	diTestStaticPNP24V				: DINT;
	diTestStaticNPN24V				: DINT;
	diTestStaticPNPGND				: DINT;	
	diTestStaticNPNGND				: DINT;
	
	diTestPNPSeqOnceComplete		: DINT;

	arrdiTestPNPSeqOnceComplete		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arrdiTestPNPSeqOnceCompleteTmp	: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;

	arrdiTestNPNSeqOnceComplete		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arrdiTestNPNSeqOnceCompleteTmp	: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;

	arrdiTestNPNSeqOnceCompleteProblemIndex		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	
	arrudiStaticCopyResultPNP24V	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF UDINT;
	arrudiStaticCopyResultNPN24V	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF UDINT;
	arrudiStaticCopyResultPNPGND	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF UDINT;
	arrudiStaticCopyResultNPNGND	: ARRAY[0..gc.uiMaxNrOfDMXChannel] OF UDINT;	

	arr_diTestPNPMotorDir1		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestNPNMotorDir1		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestPNPMotorDir2		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	arr_diTestNPNMotorDir2		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;

	
	
	diCompTestResult			: DINT;
	diCompTestResultTemp		: DINT;
	diTestResultStaticPNP		: DINT;
	diTestResultStaticNPN		: DINT;	

	arrVisu_diTestResult		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF DINT;
	uiVisuIndex					: UINT;
	tonReadWait					: TON;
	tonConvert					: TON;
	tonWriteCopyWait			: TON;
	tonTestIterGap				: TON;
	tTestTime					: TIME;
	tWriteWaitTime				: TIME;
	r_tSetConfig				: R_TRIG;
	uiRecipeIndexRcv			: UINT;
	uiMinRecipeIndex			: UINT;
	uiMaxRecipeIndex			: UINT;
	cuiMinDUTIndex				: UINT	:= 0; // Constant
	uiMaxRecipeIndexTemp		: UINT;
	
	arruiStat24VTestIndices		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT;
	arruiStatGNDTestIndices		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT;
	arruiSeqTestIndicesDMX		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT;
	arruiSeqTestIndicesDC		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT;
	arruiSeqTestIndicesMP		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT; //Motor Primary
	arruiSeqTestIndicesMS		: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT; //Motor Secondary
	
	uiLoopIter					: UINT;
//	arruiSeqTestIndicesDMXSW	: ARRAY[0..gc.uiMaxNrDMXTestCh] OF UINT;
	
		
	udiMemCpyResultPNP			: UDINT;
	udiMemCpyResultDMX			: UDINT;	
	r_tSetExpectedBuff			: R_TRIG;
	r_tExpectedBufferSet		: R_TRIG;
	uiLoopExpctdIndexRead		: UINT;
	uiLoopExpctdIndexWrite		: UINT;
	xTestBoolDelete				: BOOL;
	uiForLoopZeroStorageArray	: UINT;
	
	//For DUT Config
	r_tSetDUTVal				: R_TRIG;
	usiDUTVal					: USINT;
	uiForLoopDUTIter			: UINT;
	iSetDUTSM					: INT;
	
	//For 'Invert Recipe Settings'
	uiStartingIndex				: UINT;
	uiEndingIndex				: UINT;
	uiRecipeInvertIter			: UINT;
	R_TInvertRecipe				: R_TRIG;
	iInvertRecipeSM				: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[SeqTestOnce();
//SeqTestTwice();
//SeqTestOnceDC();
InvertRecipeSettings();
rt_RunStaticTest();
rt_ResetTest();
r_tSetConfig();//Set config when file is loaded; this condition happens when End-of-File (EOF) is reached; set by HMI button
r_tSetExpectedBuff(CLK:=r_tSetConfig.Q);
r_tExpectedBufferSet();
r_tStaticTestDone(CLK			:= (iCompareStaticSM = 110));
r_tSetDUTVal();
tonReadWait(PT		:= tTestTime);
tonConvert(PT		:= tTestTime);
tonWriteCopyWait(PT	:= tWriteWaitTime);
tonTestIterGap(PT	:= tTestTime);
tTestTime			:= T#80MS;
//just an example one
tWriteWaitTime		:= T#10MS; // same as the tOffDelay set to the input debounce FB
//DMX DUT Channels, Software 0-255 
//DMX Config Channels, Software, 256-511
//DMX DUT Channels, Hardware 1-256
//DMX Config Channels, Hardware, 257-512

//Interface Link - continued - DMXTest Local Vars

//"Config Complete" Expctd Buffer, and "Config Complete" Received Buffer; then Global Comparison is like 'masking' all but one channel at a time;

CASE iParseFile OF

0:
IF P_TextModeRead.r_tFileChg.Q THEN
	xFileImported		:= FALSE;	
	iParseFile			:= 5;
END_IF

5:
IF P_TextModeRead.fbFileGets.bEOF THEN
	uiForLoopRecipe	:= 0; // Reset the iterator used in the next state of the SM
	iParseFile		:= 10;
END_IF
	
10://At first check for any recipe items specified in the file;
//Load the recipe data into respective arrays
//For recipe indices = 0 to 255, parse the file to read the recipe index, DMX channel, and channel type
FOR uiForLoopRecipe := 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	//Read the Recipe Index
	arr_uiRecipeIndexTmp[uiForLoopRecipe]		:= STRING_TO_UINT(P_TextModeRead.database[uiForLoopRecipe,0]);
	//Read the DMX Channel for the DUT
	arruiDMXChDUTTmp[uiForLoopRecipe]			:= STRING_TO_UINT(P_TextModeRead.database[uiForLoopRecipe,1]);
	//Read the type of Channel on the DUT
	arrsDUTChTypeTmp[uiForLoopRecipe]			:= P_TextModeRead.database[uiForLoopRecipe,2];
END_FOR
//Stash the values from temp (inside FOR loop) to other arrays
arr_uiRecipeIndex	:= arr_uiRecipeIndexTmp;
arruiDMXChDUT		:= arruiDMXChDUTTmp; //DUT = Device Under Test 
arrsDUTChType		:= arrsDUTChTypeTmp; //DUT = Device Under Test

//If the 'TextModeRead' re-enters 'Ready' state then advance this SM
IF P_TextModeRead.step = 0 THEN
	xFileImported		:= TRUE;
	iParseFile			:= 0;	
END_IF

END_CASE

CASE iSetConfig OF

//Don't look at the P_TextRead; evaluate on the arrays just imported

Trig_SetConfigSM:
IF r_tSetConfig.Q THEN
	iSetConfig			:= ApplyRecipeCfgtoHW;	
END_IF

ApplyRecipeCfgtoHW:
//Read the string that is loaded from file reader; pass value to DMX Function Block, at the appropriate Config index
//This is the setting to control the position of the 'config' relays on the tester
//Ensure that the declared arrays are sufficiently long to handle the max conceivable value (ie., with the addition of an offset = 256)
FOR uiForLoopRecipe := 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiForLoopRecipe] = 'DMX') OR (arrsDUTChType[uiForLoopRecipe] = 'GND') THEN
		//Set the config routing := NPN
		arr_usiRecipeSettingTmpRd1[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 255;
		arr_usiRecipeSettingTmpRd2[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 255;
	ELSIF (arrsDUTChType[uiForLoopRecipe] = '24V') THEN
		//Set the config routing := PNP
		arr_usiRecipeSettingTmpRd1[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 0;
		arr_usiRecipeSettingTmpRd2[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 0;
	END_IF
	
	// Set config values for Round1/Round2 for Motor Primary & Motor Secondary
	IF (arrsDUTChType[uiForLoopRecipe] = 'MP') THEN
		arr_usiRecipeSettingTmpRd1[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 255;
		arr_usiRecipeSettingTmpRd2[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 0;
	ELSIF (arrsDUTChType[uiForLoopRecipe] = 'MS') THEN
		arr_usiRecipeSettingTmpRd1[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 0;
		arr_usiRecipeSettingTmpRd2[(uiForLoopRecipe+gc.uiChannelSplitCount)]	:= 255;
	END_IF
END_FOR
//Stash the values from temp (inside FOR loop) to other arrays (* Start with config for round#1 *)
arr_usiRecipeSetting		:= arr_usiRecipeSettingTmpRd1;
xRecipeSettingCompleteRd1	:= TRUE;

	iSetConfig			:= ZeroIndexArrays;	

ZeroIndexArrays:
//Zero Arrays of Indices
FOR uiForLoopZeroStorageArray	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	arruiStat24VTestIndices[uiForLoopZeroStorageArray]		:= 0;
	arruiStatGNDTestIndices[uiForLoopZeroStorageArray]		:= 0;
	arruiSeqTestIndicesDMX[uiForLoopZeroStorageArray]		:= 0;
	arruiSeqTestIndicesDC[uiForLoopZeroStorageArray]		:= 0;
	arruiSeqTestIndicesMP[uiForLoopZeroStorageArray]		:= 0;
	arruiSeqTestIndicesMS[uiForLoopZeroStorageArray]		:= 0;
END_FOR

//Ensure Loop Iter is set to 0
uiLoopIter			:= 0;
iSetConfig			:= Set24VIndices;	
	
Set24VIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = '24V') AND (arruiDMXChDUT[uiLoopIter] = 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiStat24VTestIndices[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= SetGNDIndices;

SetGNDIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = 'GND') AND (arruiDMXChDUT[uiLoopIter] = 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiStatGNDTestIndices[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= SetDMXIndices;

SetDMXIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = 'DMX') AND (arruiDMXChDUT[uiLoopIter] <> 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiSeqTestIndicesDMX[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= SetDCIndices;

SetDCIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = '24V') AND (arruiDMXChDUT[uiLoopIter] <> 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiSeqTestIndicesDC[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= SetMPIndices;

SetMPIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = 'MP') AND (arruiDMXChDUT[uiLoopIter] <> 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiSeqTestIndicesMP[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= SetMSIndices;

SetMSIndices:
FOR uiLoopIter	:= 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	IF (arrsDUTChType[uiLoopIter] = 'MS') AND (arruiDMXChDUT[uiLoopIter] <> 0)  THEN
		MEMCPY(srcAddr:=ADR(arr_uiRecipeIndex[uiLoopIter]),destAddr:=ADR(arruiSeqTestIndicesMS[uiLoopIter]),n:=SIZEOF(arr_uiRecipeIndex[uiLoopIter])); //UINT = 4 bytes?
	END_IF
END_FOR

uiLoopIter			:= 0;
iSetConfig			:= ConfigDone;

END_CASE


//Set the config of the 'routing' channels for the device - trigger
IF xRecipeSettingCompleteRd1 THEN
	g_ast.DMXHWOut				:= g_ast.DMXPhysOut;
	xRecipeSettingCompleteRd1	:= FALSE;
END_IF

IF xRecipeSettingCompleteRd2 THEN
	g_ast.DMXHWOut				:= g_ast.DMXPhysOut;
	xRecipeSettingCompleteRd2	:= FALSE;
END_IF



// For manual setting of channels from the Visualization - NOTE! This stamps over any other values set for the lower 256 channels (DUT)
CASE iSetDUTSM OF
	
0:
IF r_tSetDUTVal.Q THEN
	iSetDUTSM		:= 10;
END_IF

10:
FOR uiForLoopDUTIter := 0 TO gc.uiDUTConfigCountSplit BY 1 DO
	g_ast.DMXHWOut[uiForLoopDUTIter] 	:= usiDUTVal;
END_FOR
//g_ast.DMXHWOut					:= g_ast.DMXPhysOut;

IF NOT r_tSetDUTVal.Q THEN
	iSetDUTSM	:= 0;
END_IF

END_CASE


CASE iSetExpctdBufferSM OF
	
0://If there is a trigger to set the test config, create a new 'Expctd' buffer
IF r_tSetExpectedBuff.Q THEN
//Why does it need to be reset low?
//	r_tExpectedBufferSet.CLK	:= FALSE;
	//Clear the existing buffers
	FOR uiForLoopClearExpctd := 0 TO gc.uiMaxNrOfDMXChannel BY 1 DO
		arrxExpctBufferPNP24V[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPN24V[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferPNPGND[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPNGND[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferPNPDC[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPNDC[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferPNPDMX[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPNDMX[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferPNPMP[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPNMP[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferPNPMS[uiForLoopClearExpctd]	:= 0;
		arrxExpctBufferNPNMS[uiForLoopClearExpctd]	:= 0;
	END_FOR
	iSetExpctdBufferSM			:= 10;
END_IF

10: // Set Expected Buffers per Recipe Files
FOR uiLoopExpctdIndex := 0 TO gc.uiMaxNrOfDMXChannel BY 1 DO
	IF (arr_usiRecipeSetting[uiLoopExpctdIndex] <= 127) THEN
		arrxExpctdPNP[arr_uiRecipeIndex[uiLoopExpctdIndex]]		:= TRUE; 
		arrxExpctdNPN[arr_uiRecipeIndex[uiLoopExpctdIndex]]		:= FALSE;
	ELSIF (arr_usiRecipeSetting[uiLoopExpctdIndex] > 127) THEN
		arrxExpctdPNP[arr_uiRecipeIndex[uiLoopExpctdIndex]]		:= FALSE;
		arrxExpctdNPN[arr_uiRecipeIndex[uiLoopExpctdIndex]]		:= TRUE; 
	END_IF
	//Zero out Expected, type-specific index buffers
	arrxExpctdTmpPNP24V[uiLoopExpctdIndex] 					:= 0;
	arrxExpctdTmpNPN24V[uiLoopExpctdIndex] 					:= 0;
	arrxExpctdTmpPNPGND[uiLoopExpctdIndex] 					:= 0;
	arrxExpctdTmpNPNGND[uiLoopExpctdIndex] 					:= 0;
END_FOR

r_tExpectedBufferSet.CLK	:= TRUE;
iSetExpctdBufferSM			:= 0;

END_CASE

CASE iReindexExpctedBufferSM OF
	
0:
IF r_tExpectedBufferSet.Q THEN
	iReindexExpctedBufferSM	:= 10;
END_IF

10://Copy the contents of Expected Buffer to a different Buffer, starting at array address 0 - only the channels that have a hardware input index
MEMCPY(srcAddr:=ADR(arrxExpctdPNP[gc.uiChannelSplitCount]),destAddr:=ADR(arrxExpctdTmpPNP[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
MEMCPY(srcAddr:=ADR(arrxExpctdNPN[gc.uiChannelSplitCount]),destAddr:=ADR(arrxExpctdTmpNPN[cuiMinDUTIndex]),n:=gc.uiChannelsUT);

iReindexExpctedBufferSM	:= 20;

20:
//And create the comparison Expected Buffer for Static Test - 24V & GND indices
FOR uiCounter5 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	IF arrui24VTestIndices[uiCounter5] <> 0 THEN	
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP[arrui24VTestIndices[uiCounter5]]),destAddr:=ADR(arrxExpctdTmpPNP24V[arrui24VTestIndices[uiCounter5]]),n:=SIZEOF(arrxExpctdTmpPNP[arrui24VTestIndices[uiCounter5]])); //bytes
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN[arrui24VTestIndices[uiCounter5]]),destAddr:=ADR(arrxExpctdTmpNPN24V[arrui24VTestIndices[uiCounter5]]),n:=SIZEOF(arrxExpctdTmpNPN[arrui24VTestIndices[uiCounter5]])); //bytes
	END_IF
	
	IF arruiGNDTestIndices[uiCounter5] <> 0 THEN	
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP[arruiGNDTestIndices[uiCounter5]]),destAddr:=ADR(arrxExpctdTmpPNPGND[arruiGNDTestIndices[uiCounter5]]),n:=SIZEOF(arrxExpctdTmpPNP[arruiGNDTestIndices[uiCounter5]])); //bytes
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN[arruiGNDTestIndices[uiCounter5]]),destAddr:=ADR(arrxExpctdTmpNPNGND[arruiGNDTestIndices[uiCounter5]]),n:=SIZEOF(arrxExpctdTmpNPN[arruiGNDTestIndices[uiCounter5]])); //bytes
	END_IF	
END_FOR

iReindexExpctedBufferSM	:= 0;

END_CASE


CASE iCompareStaticSM OF
	
0: // If test is triggered by user
IF rt_RunStaticTest.Q THEN
	xStatTestInProgress						:= TRUE;
	uiLoopRcvIndex							:= cuiMinDUTIndex; 
	iCompareStaticSM						:= 10;
END_IF

10: // Zero out all comparison buffers before each comparison
//IF (uiLoopRcvIndex=0) THEN
	IF xStatTestInProgress THEN
		//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
		//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiDUTConfigCountSplit BY 1 DO
			arrxRcvdBufferPNP24V[uiCounter4]	:= 0;		
			arrxRcvdBufferNPN24V[uiCounter4]	:= 0;		
			arrxRcvdBufferPNPGND[uiCounter4]	:= 0;		
			arrxRcvdBufferNPNGND[uiCounter4]	:= 0;		
			g_ast.DMX[uiCounter4].IQ.xCmdOff	:= TRUE;	
		END_FOR
	iCompareStaticSM				:= 20;
	END_IF
(*
ELSIF (uiLoopRcvIndex>0) THEN
	IF xStatTestInProgress AND tonTestIterGap.Q THEN
		tonTestIterGap.IN	:= FALSE;
		//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
		//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiDUTConfigCountSplit BY 1 DO
			arrxRcvdBufferPNP24V[uiCounter4]	:= 0;		
			arrxRcvdBufferNPN24V[uiCounter4]	:= 0;		
			arrxRcvdBufferPNPGND[uiCounter4]	:= 0;		
			arrxRcvdBufferNPNGND[uiCounter4]	:= 0;		
		END_FOR
	iCompareStaticSM				:= 30; // don't write the hardware value (skip 20)
	END_IF
END_IF
*)
	
20:	
//write 'hardware-clear' state 
g_ast.DMXHWOut					:= g_ast.DMXPhysOut;
iCompareStaticSM				:= 30;

30: //Set the Expected Mask & write data to controller
(*
IF uiLoopRcvIndex <> 0 THEN
//	g_ast.DMX[uiLoopRcvIndex].IQ.xCmdOn			:= TRUE;
	FOR uiCounter3 := cuiMinDUTIndex TO gc.uiMaxNrDMXTestCh BY 1 DO
		IF uiCounter3 <> uiLoopRcvIndex THEN
			g_ast.DMX[uiCounter3].IQ.xCmdOff	:= TRUE;	
		END_IF
	END_FOR
	iCompareStaticSM		:= 40;
ELSE //uiLoopRcvIndex = 0
	*)
tonWriteCopyWait.IN		:= TRUE;
iCompareStaticSM		:= 50;
//END_IF

40:
//Write DMX channels
(*
g_ast.DMXHWOut			:= g_ast.DMXPhysOut;
tonWriteCopyWait.IN		:= TRUE;
iCompareStaticSM		:= 50;
*)

50:
IF tonWriteCopyWait.Q THEN
	tonWriteCopyWait.IN	:= FALSE;
	iCompareStaticSM	:= 60;
END_IF

60:
FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO

//IF there is an index for a '24V' element, then copy that element's value to a new pair of arrays, for 'Received'

	IF arrui24VTestIndices[uiCounter4] <> 0 THEN

		arrudiStaticCopyResultPNP24V[arrui24VTestIndices[uiCounter4]]	:= MEMCPY(srcAddr:=ADR(g_ast.arrInputPNP[arrui24VTestIndices[uiCounter4]]),destAddr:=ADR(arrxRcvdBufferPNP24V[arrui24VTestIndices[uiCounter4]]),n:=SIZEOF(g_ast.arrInputPNP[arrui24VTestIndices[uiCounter4]])); //bytes
		arrudiStaticCopyResultNPN24V[arrui24VTestIndices[uiCounter4]]	:= MEMCPY(srcAddr:=ADR(g_ast.arrInputNPN[arrui24VTestIndices[uiCounter4]]),destAddr:=ADR(arrxRcvdBufferNPN24V[arrui24VTestIndices[uiCounter4]]),n:=SIZEOF(g_ast.arrInputNPN[arrui24VTestIndices[uiCounter4]])); //bytes)

	END_IF

//IF there is an index for a 'GND' element, then copy that element's value to a new pair of arrays, for 'Received'

	IF arruiGNDTestIndices[uiCounter4] <> 0 THEN

		arrudiStaticCopyResultPNPGND[arruiGNDTestIndices[uiCounter4]]	:= MEMCPY(srcAddr:=ADR(g_ast.arrInputPNP[arruiGNDTestIndices[uiCounter4]]),destAddr:=ADR(arrxRcvdBufferPNPGND[arruiGNDTestIndices[uiCounter4]]),n:=SIZEOF(g_ast.arrInputPNP[arruiGNDTestIndices[uiCounter4]])); //bytes
		arrudiStaticCopyResultNPNGND[arruiGNDTestIndices[uiCounter4]]	:= MEMCPY(srcAddr:=ADR(g_ast.arrInputNPN[arruiGNDTestIndices[uiCounter4]]),destAddr:=ADR(arrxRcvdBufferNPNGND[arruiGNDTestIndices[uiCounter4]]),n:=SIZEOF(g_ast.arrInputNPN[arruiGNDTestIndices[uiCounter4]])); //bytes)
	
	END_IF
	
END_FOR

iCompareStaticSM			:= 70;

70:
tonReadWait.IN				:= TRUE;
iCompareStaticSM			:= 80;

80: // if wait completed, set the bit for conversion high
//Conversion Function call
IF tonReadWait.Q THEN
	tonReadWait.IN					:= FALSE;
	iCompareStaticSM				:= 90;
END_IF

90:
//Run Comparos
//Individual Channels comparison
FOR uiCounter6	:= 0 TO gc.uiMaxNrDMXTestCh BY 1 DO 
	arr_diTestStaticPNP24V[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNP24V[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferPNP24V[uiCounter6]),n:=SIZEOF(arrxExpctdTmpPNP24V[uiCounter6]));
	arr_diTestStaticNPN24V[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPN24V[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferNPN24V[uiCounter6]),n:=SIZEOF(arrxExpctdTmpNPN24V[uiCounter6]));
	arr_diTestStaticPNPGND[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNPGND[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferPNPGND[uiCounter6]),n:=SIZEOF(arrxExpctdTmpPNPGND[uiCounter6]));
	arr_diTestStaticNPNGND[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNGND[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferNPNGND[uiCounter6]),n:=SIZEOF(arrxExpctdTmpNPNGND[uiCounter6]));
END_FOR

//Complete Buffer
diTestStaticPNP24V		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNP24V[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferPNP24V[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
diTestStaticNPN24V		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPN24V[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferNPN24V[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
diTestStaticPNPGND		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNPGND[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferPNPGND[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
diTestStaticNPNGND		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNGND[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferNPNGND[cuiMinDUTIndex]),n:=gc.uiChannelsUT);

iCompareStaticSM				:= 105;

(*
100: // If counter is equal to the max # of test channels, reset it; turn off the DMX channels that were turned on in the course of the test
IF (uiLoopRcvIndex = gc.uiMaxNrDMXTestCh) THEN
	rt_RunStaticTest.CLK			:= TRUE;
	iCompareStaticSM				:= 110;
ELSE
	uiLoopRcvIndex				:= uiLoopRcvIndex +1;
	//Next iteration
	tonTestIterGap.IN			:= TRUE;
	iCompareStaticSM			:= 10;
 (*iCounter <> gc.usiMaxNrOfChannels*)
END_IF
*)

105:
//Retrieving the discrepant indices for display on HMI
FOR uiVisuIndex := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	IF (arr_diTestStaticPNP24V[uiVisuIndex] <> 0) THEN
		arrVisu_diTestResult[uiVisuIndex]	:= uiVisuIndex;	
	ELSIF (arr_diTestStaticNPNGND[uiVisuIndex] <> 0) THEN
		arrVisu_diTestResult[uiVisuIndex]	:= uiVisuIndex;	
	END_IF
END_FOR

iCompareStaticSM				:= 110;
	
110:
xStatTestInProgress				:= FALSE;
iCompareStaticSM				:= 120;

120:
IF rt_ResetTest.Q AND NOT rt_RunStaticTest.Q THEN
	FOR uiCounter2 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO 
		arr_diTestStaticPNP24V[uiCounter2]		:= 0;
		arr_diTestStaticNPN24V[uiCounter2]		:= 0;
		arr_diTestStaticPNPGND[uiCounter2]		:= 0;
		arr_diTestStaticNPNGND[uiCounter2]		:= 0;
	END_FOR
	diCompTestResult							:= 0;
	iCompareStaticSM							:= 0; (* reset to beginning *)
END_IF

END_CASE


//Linked to the Visualization Table
//FOR uiVisuIndex := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	//	arrVisu_diTestResult[0,uiVisuIndex]	:= g_ast.DMXHWOut[uiVisuIndex]; //Sent
	//	arrVisu_diTestResult[1,uiVisuIndex]	:= arrbySclPNP[uiVisuIndex]; //Received
	//	arrVisu_diTestResult[2,uiVisuIndex]	:= arr_diTestResultPNP[uiVisuIndex]; //Result of Comparison
	//	arrVisu_diTestResult[3,uiVisuIndex]	:= arr_diTestResultNPN[uiVisuIndex]; //Result of Comparison
//END_FOR



//IF diCompTestResultTemp = -1 OR diCompTestResultTemp = 1 THEN
//	diCompTestResult	:= diCompTestResultTemp;
//END_IF]]></ST>
    </Implementation>
    <Action Name="InvertRecipeSettings" Id="{ab56e97d-bd56-40c0-9de3-e9e4dcae7cf6}">
      <Implementation>
        <ST><![CDATA[R_TInvertRecipe();

CASE iInvertRecipeSM OF
	
0:
IF R_TInvertRecipe.Q THEN
	iInvertRecipeSM		:= 10;
END_IF

10:
FOR uiRecipeInvertIter := uiStartingIndex TO uiEndingIndex BY 1 DO 
	IF arr_usiRecipeSetting[uiRecipeInvertIter] = 0 THEN
		arr_usiRecipeSetting[uiRecipeInvertIter]	:= 255;
	ELSIF arr_usiRecipeSetting[uiRecipeInvertIter] <> 0 THEN
		arr_usiRecipeSetting[uiRecipeInvertIter]	:= 0;
	END_IF
END_FOR

iInvertRecipeSM		:= 20;

20:
IF NOT R_TInvertRecipe.Q THEN
	iInvertRecipeSM		:= 0;
END_IF

END_CASE]]></ST>
      </Implementation>
    </Action>
    <Method Name="METH" Id="{7f4ce2af-04c6-49a3-82d9-d76d3d072c2f}">
      <Declaration><![CDATA[METHOD METH : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="METH_1" Id="{a5dc05e5-cddc-4f12-b1d3-4d90e01cfbbb}">
      <Declaration><![CDATA[METHOD METH_1 : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="METH_2" Id="{4ede8091-4ac4-4889-a687-719bd1f34d60}">
      <Declaration><![CDATA[METHOD METH_2 : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="METH_3" Id="{d3c52faa-5fab-433e-806d-7ac9e6628f1a}">
      <Declaration><![CDATA[METHOD METH_3 : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="METH_4" Id="{c22c9153-ac85-4e47-9ee5-7e57cd7f1377}">
      <Declaration><![CDATA[METHOD METH_4 : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Action Name="SeqTestMotor" Id="{8ebcdac7-001b-4114-a17b-b08d6ad9551b}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="SeqTestOnce" Id="{da9d395e-68b9-4202-9635-b7973c50d5fe}">
      <Implementation>
        <ST><![CDATA[//Run Once - DMX Channels only for now

rt_RunSeqTestOnce();
rt_ResetTestSeq();

CASE iCompareSeq[ENUM_SeqSM.Once] OF
	
0: // If test is triggered by user
//Trigger should be something like 
IF rt_RunSeqTestOnce.Q THEN
	xDMXSeqTestInProgressOnce				:= TRUE;
	uiLoopRcvIndex							:= cuiMinDUTIndex; 
	iCompareSeq[ENUM_SeqSM.Once]			:= 10;
END_IF

10: // Zero out all comparison buffers before each comparison
IF (uiLoopRcvIndex=0) THEN
	IF xDMXSeqTestInProgressOnce THEN
//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
			arrxExpctdTmpPNPSeqDMX[uiCounter4]		:= 0;		//should be all 0s ; PNP<>DMX
			arrxExpctdTmpNPNSeqDMX[uiCounter4]		:= 0;
//			arrxExpctdTmpPNPSeqDC[uiCounter4]		:= 0;		
//			arrxExpctdTmpNPNSeqDC[uiCounter4]		:= 0;
			arrxRcvdBufferPNPSeq[uiCounter4]		:= 0;		//should be all 0s too ; PNP<>DMX	
			arrxRcvdBufferNPNSeq[uiCounter4]		:= 0;			
			g_ast.DMX[uiCounter4].IQ.xCmdOff		:= TRUE;	
		END_FOR
	iCompareSeq[ENUM_SeqSM.Once]					:= 20;
	END_IF
ELSIF (uiLoopRcvIndex>0) THEN // to avoid 
	IF xDMXSeqTestInProgressOnce AND tonTestIterGap.Q THEN
		tonTestIterGap.IN	:= FALSE;
		//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
		//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
			arrxExpctdTmpPNPSeqDMX[uiCounter4]		:= 0;		//should be all 0s - PNP<>DMX
			arrxExpctdTmpNPNSeqDMX[uiCounter4]		:= 0;
			arrxRcvdBufferPNPSeq[uiCounter4]		:= 0;		
			arrxRcvdBufferNPNSeq[uiCounter4]		:= 0;
		END_FOR
		
	iCompareSeq[ENUM_SeqSM.Once]					:= 20; // don't write the hardware value (skip 20)
	END_IF	
END_IF
	
20:	
//write 'hardware-clear' state 
g_ast.DMXHWOut									:= g_ast.DMXPhysOut;

iCompareSeq[ENUM_SeqSM.Once]					:= 25;

25:
//Copy static test indices from Expected_Static - as these should still be used for comparisons
//	IF (arrui24VTestIndices[uiCounter4] <> 0) THEN	
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP24V[cuiMinDUTIndex]),destAddr:=ADR(arrxExpctdTmpPNPSeqDMX[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	arrxExpctdTmpPNPSeqDMX[uiCounter4]		:= arrxExpctdTmpPNP24V[uiCounter4];
	arrxExpctdTmpNPNSeqDMX[uiCounter4]		:= arrxExpctdTmpNPNGND[uiCounter4];
END_FOR

iCompareSeq[ENUM_SeqSM.Once]					:= 30;

30: //Set the Expected Mask & write data to controller
//Write the first index from the specified array of indices
//MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpNPNSeqDMX[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),n:=SIZEOF(arrxExpctdTmpNPN[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]));	

//This line copies only the value of the current iterator's index in the DMX Channel Array
arrxExpctdTmpNPNSeqDMX[uiLoopRcvIndex]	:= arrxExpctdTmpNPN[uiLoopRcvIndex];

iCompareSeq[ENUM_SeqSM.Once]			:= 35;

35:
IF (arruiSeqTestIndicesDMXSW[uiLoopRcvIndex] <> 0) THEN
//Also copy this specific channel index value to the comparison array
	
//Don't copy PNP indices for DMX; this doesn't generally make sense
//	MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpPNPSeqDMX[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),n:=1);
	
	//CmdOn - command on - that respective channel
	g_ast.DMX[arruiSeqTestIndicesDMXSW[uiLoopRcvIndex]].IQ.xCmdOn			:= TRUE;
	//and turn off all others
	FOR uiCounter3 := cuiMinDUTIndex TO gc.uiMaxNrDMXTestCh BY 1 DO
		IF uiCounter3 <> arruiSeqTestIndicesDMXSW[uiLoopRcvIndex] THEN
			g_ast.DMX[uiCounter3].IQ.xCmdOff	:= TRUE;	
		END_IF
	END_FOR
END_IF

iCompareSeq[ENUM_SeqSM.Once]		:= 40;

40:
//Write to hardware
g_ast.DMXHWOut							:= g_ast.DMXPhysOut;
//tonWriteCopyWait.IN						:= TRUE;
iCompareSeq[ENUM_SeqSM.Once]			:=	60;

(*
50:

//Timer marks end of sampling period; reset timer
IF tonWriteCopyWait.Q THEN
	tonWriteCopyWait.IN					:=	FALSE;
	iCompareSeq[ENUM_SeqSM.Once]		:=	60;
END_IF
*)

60:
//Log all the 'gates' - returned from FB_Debounce
FOR uiCounter3	:= 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	arrxRcvdBufferNPNSeq[uiCounter3]		:= g_ast.arrFBIntNPN[uiCounter3].Q.xGate;
END_FOR
	
iCompareSeq[ENUM_SeqSM.Once]		:=	70;

//IF tonReadWait.Q THEN
//	tonReadWait.IN					:= FALSE;
//Copy hardware state
//	arrxRcvdBufferNPNSeq			:= arrxTestChInputNPN; // linked to hardware
//	arrxRcvdBufferPNPSeq			:= arrxTestChInputPNP; // linked to hardware
//iCompareSeq[ENUM_SeqSM.Once]		:= 90;
//END_IF

70:
//Run Comparos
//Individual
arr_diTestNPNSeqOnceLine[uiLoopRcvIndex]			:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNSeqDMX[uiLoopRcvIndex]),pBuf2:=ADR(arrxRcvdBufferNPNSeq[uiLoopRcvIndex]),n:=SIZEOF(arrxExpctdTmpNPNSeqDMX[uiLoopRcvIndex])); 
//Complete Buffer
arrdiTestNPNSeqOnceComplete[uiLoopRcvIndex]			:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNSeqDMX[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferNPNSeq[cuiMinDUTIndex]),n:=gc.uiChannelsUT); 

//log the error index - later

iCompareSeq[ENUM_SeqSM.Once]				:= 80;

80: //Turn off all DMX channels after comparison
FOR uiCounter3 := cuiMinDUTIndex TO gc.uiMaxNrDMXTestCh BY 1 DO
	g_ast.DMX[uiCounter3].IQ.xCmdOff		:= TRUE;
END_FOR

90://Write to DMX hardware, advance state
g_ast.DMXHWOut								:= g_ast.DMXPhysOut;

iCompareSeq[ENUM_SeqSM.Once]				:= 100;

100: //Confirm 'return' to static 
FOR uiCounter3	:= 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
	arrxRcvdBufferNPNSeq[uiCounter3]		:= g_ast.arrFBIntNPN[uiCounter3].Q.xGate;
	IF arrxRcvdBufferNPNSeq[uiCounter3] = arrxExpctdTmpNPNGND[uiCounter3] THEN
		iCompareSeq[ENUM_SeqSM.Once]				:= 110;
	END_IF
END_FOR

110://Write to DMX hardware, advance state
g_ast.DMXHWOut								:= g_ast.DMXPhysOut;

iCompareSeq[ENUM_SeqSM.Once]				:= 120;

120: // If counter is equal to the max # of test channels, reset it; else, proceed around again 
IF (uiLoopRcvIndex = gc.uiMaxNrDMXTestCh) THEN
	iCompareSeq[ENUM_SeqSM.Once]			:= 130;
ELSE
	uiLoopRcvIndex							:= uiLoopRcvIndex +1;
	//Next iteration
	tonTestIterGap.IN						:= TRUE;
	iCompareSeq[ENUM_SeqSM.Once]			:= 10;
 (*iCounter <> gc.usiMaxNrOfChannels*)
END_IF

130:
xDMXSeqTestInProgressOnce					:= FALSE;
iCompareSeq[ENUM_SeqSM.Once]				:= 140;

140:
IF rt_ResetTestSeq.Q AND NOT rt_RunSeqTestOnce.Q THEN
	FOR uiCounter2 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO 
		arr_diTestPNPSeqOnceLine[uiCounter2]		:= 0;
		arr_diTestNPNSeqOnceLine[uiCounter2]		:= 0;
//		arrdiTestPNPSeqOnceComplete[uiCounter2]		:= 0;
//		arrdiTestNPNSeqOnceComplete[uiCounter2]		:= 0;
		arrdiTestNPNSeqOnceCompleteProblemIndex[uiCounter2]	:= 0;
	END_FOR
	diCompTestResult							:= 0;
	iCompareSeq[ENUM_SeqSM.Once]				:= 0; (* reset to beginning *)
END_IF

END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="SeqTestOnceDC" Id="{a6580177-07fa-4403-b780-55710f1004e3}">
      <Implementation>
        <ST><![CDATA[//Run Once - DMX Channels only for now

rt_RunSeqTestOnceDC();
rt_ResetTestSeqDC();

CASE iCompareSeq[ENUM_SeqSM.OnceDC] OF
	
0: // If test is triggered by user
//Trigger should be something like 
IF rt_RunSeqTestOnceDC.Q THEN
	xDMXSeqTestInProgressOnceDC				:= TRUE;
	uiLoopRcvIndex							:= cuiMinDUTIndex; 
	iCompareSeq[ENUM_SeqSM.OnceDC]			:= 10;
END_IF

10: // Zero out all comparison buffers before each comparison
IF (uiLoopRcvIndex=0) THEN
	IF xDMXSeqTestInProgressOnceDC THEN
//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
			arrxExpctdTmpPNPSeqDC[uiCounter4]		:= 0;		//should be all 0s ; PNP<>DMX
			arrxExpctdTmpNPNSeqDC[uiCounter4]		:= 0;
//			arrxExpctdTmpPNPSeqDC[uiCounter4]		:= 0;		
//			arrxExpctdTmpNPNSeqDC[uiCounter4]		:= 0;
			arrxRcvdBufferPNPSeq[uiCounter4]		:= 0;		//should be all 0s too ; PNP<>DMX	
			arrxRcvdBufferNPNSeq[uiCounter4]		:= 0;			
			g_ast.DMX[uiCounter4].IQ.xCmdOff		:= TRUE;	
		END_FOR
	iCompareSeq[ENUM_SeqSM.OnceDC]					:= 20;
	END_IF
ELSIF (uiLoopRcvIndex>0) THEN // to avoid 
	IF xDMXSeqTestInProgressOnceDC AND tonTestIterGap.Q THEN
		tonTestIterGap.IN	:= FALSE;
		//by default, Counter = 0 at the first initialization; it is reset at the end of this State Machine
		//Clear Storage Buffers pre-test to ensure no old data interferes with current test
		FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
			arrxExpctdTmpPNPSeqDC[uiCounter4]		:= 0;		//should be all 0s - PNP<>DMX
			arrxExpctdTmpNPNSeqDC[uiCounter4]		:= 0;
			arrxRcvdBufferPNPSeq[uiCounter4]		:= 0;		
			arrxRcvdBufferNPNSeq[uiCounter4]		:= 0;		
		END_FOR
		
	iCompareSeq[ENUM_SeqSM.OnceDC]					:= 25; // don't write the hardware value (skip 20)
	END_IF	
END_IF
	
20:	
//write 'hardware-clear' state 
g_ast.DMXHWOut									:= g_ast.DMXPhysOut;

iCompareSeq[ENUM_SeqSM.OnceDC]					:= 25;

25:
//Copy static test indices from Expected_Static - as these should still be used for comparisons
//FOR uiCounter4 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
//	IF (arrui24VTestIndices[uiCounter4] <> 0) THEN	
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP24V[cuiMinDUTIndex]),destAddr:=ADR(arrxExpctdTmpPNPSeqDC[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN24V[cuiMinDUTIndex]),destAddr:=ADR(arrxExpctdTmpNPNSeqDMX[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP24V[arrui24VTestIndices[uiCounter4]]),destAddr:=ADR(arrxExpctdTmpPNPSeqDC[arrui24VTestIndices[uiCounter4]]),n:=1);
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN24V[arrui24VTestIndices[uiCounter4]]),destAddr:=ADR(arrxExpctdTmpNPNSeqDC[arrui24VTestIndices[uiCounter4]]),n:=1);
//	END_IF
	
//	IF (arruiGNDTestIndices[uiCounter4] <> 0) THEN	
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNPGND[cuiMinDUTIndex]),destAddr:=ADR(arrxExpctdTmpPNPSeqDMX[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPNGND[cuiMinDUTIndex]),destAddr:=ADR(arrxExpctdTmpNPNSeqDC[cuiMinDUTIndex]),n:=gc.uiChannelsUT);
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNPGND[arruiGNDTestIndices[uiCounter4]]),destAddr:=ADR([arrxExpctdTmpPNPSeqDC[uiCounter4]]),n:=1);
//		MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPNGND[arruiGNDTestIndices[uiCounter4]]),destAddr:=ADR(arrxExpctdTmpNPNSeqDC[arruiGNDTestIndices[uiCounter4]]),n:=1);
//	END_IF
//END_FOR

// Be careful not to overstamp existing arrays!  Right now MEMCPY is only addressing PNP24V & NPNGND

iCompareSeq[ENUM_SeqSM.OnceDC]					:= 30;

30: //Set the Expected Mask & write data to controller
//Write the first index from the specified array of indices
IF (arruiSeqTestIndicesDC[uiLoopRcvIndex] <> 0) THEN
//Also copy this specific channel index value to the comparison array
	
//Don't copy NPN indices for DC; this doesn't generally make sense
	MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP[arruiSeqTestIndicesDC[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpPNPSeqDC[arruiSeqTestIndicesDC[uiLoopRcvIndex]]),n:=SIZEOF(arrxExpctdTmpPNP[arruiSeqTestIndicesDC[uiLoopRcvIndex]]));
//	MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpNPNSeqDMX[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]),n:=SIZEOF(arrxExpctdTmpNPN[arruiSeqTestIndicesDMX[uiLoopRcvIndex]]));	
	
	//And Cmd - turn on - that respective channel
	g_ast.DMX[arruiSeqTestIndicesDC[uiLoopRcvIndex]].IQ.xCmdOn			:= TRUE;
	FOR uiCounter3 := cuiMinDUTIndex TO gc.uiMaxNrDMXTestCh BY 1 DO
		IF uiCounter3 <> arruiSeqTestIndicesDC[uiLoopRcvIndex] THEN
			g_ast.DMX[uiCounter3].IQ.xCmdOff	:= TRUE;	
		END_IF
	END_FOR
ELSIF (arruiSeqTestIndicesDC[uiLoopRcvIndex] = 0) THEN
	FOR uiCounter3 := cuiMinDUTIndex TO gc.uiMaxNrDMXTestCh BY 1 DO
		IF uiCounter3 <> arruiSeqTestIndicesDC[uiLoopRcvIndex] THEN
			g_ast.DMX[uiCounter3].IQ.xCmdOff	:= TRUE;	
		END_IF
	END_FOR
END_IF

iCompareSeq[ENUM_SeqSM.OnceDC]		:= 35;

35:
//Write to hardware
g_ast.DMXHWOut						:= g_ast.DMXPhysOut;

iCompareSeq[ENUM_SeqSM.OnceDC]		:= 40;

40:
//Write DMX channels
tonWriteCopyWait.IN					:= TRUE;
iCompareSeq[ENUM_SeqSM.OnceDC]		:= 50;

50:
IF tonWriteCopyWait.Q THEN
	tonWriteCopyWait.IN				:= FALSE;
	iCompareSeq[ENUM_SeqSM.OnceDC]	:= 60;
END_IF

60:
//IF there is an index for a 'Light' element, then copy that element's value to a new pair of arrays, for 'Received'
//IF arruiSeqTestIndicesDMX[uiLoopRcvIndex] <> 0 THEN
(*
FOR uiCounter6 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO 
	arr_udiMEMCPYPNPSeqOnceRcvdTmp[uiCounter6]	:= MEMCPY(srcAddr:=ADR(arrxTestChInputPNPAlias[uiCounter6]),destAddr:=ADR(arrxRcvdBufferPNPSeq[uiCounter6]),n:=SIZEOF(arrxTestChInputPNP[uiCounter6])); //bytes
	arr_udiMEMCPYNPNSeqOnceRcvdTmp[uiCounter6]	:= MEMCPY(srcAddr:=ADR(arrxTestChInputNPNAlias[uiCounter6]),destAddr:=ADR(arrxRcvdBufferNPNSeq[uiCounter6]),n:=SIZEOF(arrxTestChInputNPN[uiCounter6])); //bytes)
	//	MEMCPY(srcAddr:=ADR(arrxExpctdTmpPNP[arruiSeqTestIndices[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpPNPSeq[arruiSeqTestIndices[uiLoopRcvIndex]]),n:=1); //bytes
	//	MEMCPY(srcAddr:=ADR(arrxExpctdTmpNPN[arruiSeqTestIndices[uiLoopRcvIndex]]),destAddr:=ADR(arrxExpctdTmpNPNSeq[arruiSeqTestIndices[uiLoopRcvIndex]]),n:=1); //bytes
END_FOR
*)
//Stash
//arr_udiMEMCPYPNPSeqOnceRcvd	:= arr_udiMEMCPYPNPSeqOnceRcvdTmp;
//arr_udiMEMCPYNPNSeqOnceRcvd	:= arr_udiMEMCPYNPNSeqOnceRcvdTmp;

//END_IF

//We should also 'expect' the static indices - and if we passed the static test already - they will still be on, so grab and add those to the 'Expected' Buffer
//This is a gate to leave this state; the MEMCPY operation had to return for all values
	
(*
70:
tonReadWait.IN							:= TRUE;
iCompareSeq[ENUM_SeqSM.OnceDC]			:= 80;

80: // if wait completed, set the bit for conversion high
//Conversion Function call
IF tonReadWait.Q THEN
	tonReadWait.IN					:= FALSE;
	iCompareSeq[ENUM_SeqSM.OnceDC]	:= 90;
END_IF
*)

90:
//Run Comparos
IF iCompareStaticSM <> 90 THEN //because it uses the same iterator in StaticSM - shouldn't be the case, but this is a safeguard
	FOR uiCounter6	:= 0 TO gc.uiMaxNrDMXTestCh BY 1 DO
		arr_diTestPNPSeqOnceLineTmp[uiCounter6]			:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNPSeqDC[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferPNPSeq[uiCounter6]),n:=SIZEOF(arrxExpctdTmpPNPSeqDC[uiCounter6]));
//		arr_diTestNPNSeqOnceLineTmp[uiCounter6]			:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNSeqDMX[uiCounter6]),pBuf2:=ADR(arrxRcvdBufferNPNSeq[uiCounter6]),n:=SIZEOF(arrxExpctdTmpNPNSeqDMX[uiCounter6])); 
		arrdiTestPNPSeqOnceCompleteTmp[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpPNPSeqDC[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferPNPSeq[cuiMinDUTIndex]),n:=gc.uiChannelsUT); //UINTs are 16-bit/2 bytes
//		arrdiTestNPNSeqOnceCompleteTmp[uiCounter6]		:= MEMCMP(pBuf1:=ADR(arrxExpctdTmpNPNSeqDMX[cuiMinDUTIndex]),pBuf2:=ADR(arrxRcvdBufferNPNSeq[cuiMinDUTIndex]),n:=gc.uiChannelsUT); //UINTs are 16-bit/2 bytes
	END_FOR
arr_diTestPNPSeqOnceLine	:= arr_diTestPNPSeqOnceLineTmp;
arrdiTestPNPSeqOnceComplete	:= arrdiTestPNPSeqOnceCompleteTmp;
	
END_IF

(* log the error index 
IF arr_diTestPNPSeqOnce[uiLoopRcvIndex] <> 0 THEN
	memcpy(srcAddr:=uiLoopRcvIndex,destAddr:=, n:=2)
END_IF
*)

iCompareSeq[ENUM_SeqSM.OnceDC]				:= 100;

100: // If counter is equal to the max # of test channels, reset it; turn off the DMX channels that were turned on in the course of the test

IF (uiLoopRcvIndex = gc.uiMaxNrDMXTestCh) THEN
	iCompareSeq[ENUM_SeqSM.OnceDC]			:= 110;
ELSE
	uiLoopRcvIndex							:= uiLoopRcvIndex +1;
	//Next iteration
	tonTestIterGap.IN						:= TRUE;
	iCompareSeq[ENUM_SeqSM.OnceDC]			:= 10;
 (*iCounter <> gc.usiMaxNrOfChannels*)
END_IF

110:
xDMXSeqTestInProgressOnceDC					:= FALSE;
iCompareSeq[ENUM_SeqSM.OnceDC]				:= 120;

120:
IF rt_ResetTestSeqDC.Q AND NOT rt_RunSeqTestOnceDC.Q THEN
	FOR uiCounter2 := 0 TO gc.uiMaxNrDMXTestCh BY 1 DO 
		arr_diTestPNPSeqOnceLine[uiCounter2]		:= 0;
		arr_diTestNPNSeqOnceLine[uiCounter2]		:= 0;
		arrdiTestPNPSeqOnceComplete[uiCounter2]		:= 0;
		arrdiTestNPNSeqOnceComplete[uiCounter2]		:= 0;
	END_FOR
	diCompTestResult							:= 0;
	iCompareSeq[ENUM_SeqSM.OnceDC]				:= 0; (* reset to beginning *)
END_IF

END_CASE]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="DMXTest">
      <LineId Id="6761" Count="0" />
      <LineId Id="7189" Count="0" />
      <LineId Id="9094" Count="0" />
      <LineId Id="9275" Count="0" />
      <LineId Id="6762" Count="4" />
      <LineId Id="7937" Count="0" />
      <LineId Id="6767" Count="4" />
      <LineId Id="8323" Count="0" />
      <LineId Id="10254" Count="0" />
      <LineId Id="10066" Count="0" />
      <LineId Id="6772" Count="3" />
      <LineId Id="8914" Count="1" />
      <LineId Id="6776" Count="6" />
      <LineId Id="11433" Count="0" />
      <LineId Id="6783" Count="10" />
      <LineId Id="11221" Count="0" />
      <LineId Id="6794" Count="14" />
      <LineId Id="11431" Count="0" />
      <LineId Id="6809" Count="1" />
      <LineId Id="11225" Count="0" />
      <LineId Id="11224" Count="0" />
      <LineId Id="11227" Count="0" />
      <LineId Id="11226" Count="0" />
      <LineId Id="11228" Count="1" />
      <LineId Id="11435" Count="0" />
      <LineId Id="11434" Count="0" />
      <LineId Id="11437" Count="0" />
      <LineId Id="11441" Count="0" />
      <LineId Id="11440" Count="0" />
      <LineId Id="6811" Count="1" />
      <LineId Id="11827" Count="0" />
      <LineId Id="6813" Count="1" />
      <LineId Id="11447" Count="0" />
      <LineId Id="11461" Count="0" />
      <LineId Id="11451" Count="1" />
      <LineId Id="11772" Count="0" />
      <LineId Id="11466" Count="1" />
      <LineId Id="11457" Count="0" />
      <LineId Id="11774" Count="0" />
      <LineId Id="11458" Count="0" />
      <LineId Id="11759" Count="0" />
      <LineId Id="11771" Count="0" />
      <LineId Id="11760" Count="0" />
      <LineId Id="11764" Count="0" />
      <LineId Id="11766" Count="0" />
      <LineId Id="11763" Count="0" />
      <LineId Id="11769" Count="1" />
      <LineId Id="11762" Count="0" />
      <LineId Id="11442" Count="0" />
      <LineId Id="11468" Count="0" />
      <LineId Id="11782" Count="0" />
      <LineId Id="11776" Count="0" />
      <LineId Id="11470" Count="1" />
      <LineId Id="11796" Count="0" />
      <LineId Id="6828" Count="0" />
      <LineId Id="11799" Count="0" />
      <LineId Id="11802" Count="0" />
      <LineId Id="11805" Count="0" />
      <LineId Id="11814" Count="1" />
      <LineId Id="11820" Count="0" />
      <LineId Id="11817" Count="0" />
      <LineId Id="11819" Count="0" />
      <LineId Id="11804" Count="0" />
      <LineId Id="11849" Count="0" />
      <LineId Id="11848" Count="0" />
      <LineId Id="11800" Count="0" />
      <LineId Id="11822" Count="1" />
      <LineId Id="11825" Count="0" />
      <LineId Id="11856" Count="0" />
      <LineId Id="11847" Count="0" />
      <LineId Id="11852" Count="0" />
      <LineId Id="11851" Count="0" />
      <LineId Id="11860" Count="0" />
      <LineId Id="11866" Count="0" />
      <LineId Id="11854" Count="1" />
      <LineId Id="11858" Count="0" />
      <LineId Id="11857" Count="0" />
      <LineId Id="11872" Count="6" />
      <LineId Id="11871" Count="0" />
      <LineId Id="11879" Count="0" />
      <LineId Id="11869" Count="0" />
      <LineId Id="11862" Count="3" />
      <LineId Id="11859" Count="0" />
      <LineId Id="11880" Count="2" />
      <LineId Id="11835" Count="0" />
      <LineId Id="11834" Count="0" />
      <LineId Id="11884" Count="7" />
      <LineId Id="11839" Count="0" />
      <LineId Id="11837" Count="0" />
      <LineId Id="11893" Count="6" />
      <LineId Id="11892" Count="0" />
      <LineId Id="11841" Count="0" />
      <LineId Id="11840" Count="0" />
      <LineId Id="11900" Count="6" />
      <LineId Id="11838" Count="0" />
      <LineId Id="6945" Count="5" />
      <LineId Id="11784" Count="0" />
      <LineId Id="11778" Count="0" />
      <LineId Id="6953" Count="0" />
      <LineId Id="11786" Count="4" />
      <LineId Id="11785" Count="0" />
      <LineId Id="6954" Count="13" />
      <LineId Id="9675" Count="0" />
      <LineId Id="10442" Count="1" />
      <LineId Id="10445" Count="0" />
      <LineId Id="6968" Count="0" />
      <LineId Id="6970" Count="1" />
      <LineId Id="8638" Count="0" />
      <LineId Id="6972" Count="5" />
      <LineId Id="11707" Count="0" />
      <LineId Id="6978" Count="3" />
      <LineId Id="11739" Count="1" />
      <LineId Id="11743" Count="7" />
      <LineId Id="6982" Count="12" />
      <LineId Id="7518" Count="0" />
      <LineId Id="7520" Count="1" />
      <LineId Id="7519" Count="0" />
      <LineId Id="7522" Count="0" />
      <LineId Id="6995" Count="18" />
      <LineId Id="7479" Count="2" />
      <LineId Id="7489" Count="0" />
      <LineId Id="7494" Count="0" />
      <LineId Id="7496" Count="0" />
      <LineId Id="7498" Count="0" />
      <LineId Id="7500" Count="0" />
      <LineId Id="7491" Count="0" />
      <LineId Id="7504" Count="0" />
      <LineId Id="7506" Count="0" />
      <LineId Id="7508" Count="0" />
      <LineId Id="7510" Count="0" />
      <LineId Id="7492" Count="0" />
      <LineId Id="7653" Count="1" />
      <LineId Id="7014" Count="20" />
      <LineId Id="7037" Count="1" />
      <LineId Id="7041" Count="3" />
      <LineId Id="7784" Count="0" />
      <LineId Id="7045" Count="7" />
      <LineId Id="7055" Count="1" />
      <LineId Id="7059" Count="3" />
      <LineId Id="7786" Count="0" />
      <LineId Id="7063" Count="6" />
      <LineId Id="7788" Count="0" />
      <LineId Id="7070" Count="8" />
      <LineId Id="7787" Count="0" />
      <LineId Id="7079" Count="5" />
      <LineId Id="7789" Count="0" />
      <LineId Id="7085" Count="2" />
      <LineId Id="7790" Count="0" />
      <LineId Id="7088" Count="7" />
      <LineId Id="7097" Count="0" />
      <LineId Id="8088" Count="1" />
      <LineId Id="7513" Count="0" />
      <LineId Id="8075" Count="3" />
      <LineId Id="8084" Count="0" />
      <LineId Id="8071" Count="0" />
      <LineId Id="8085" Count="2" />
      <LineId Id="7514" Count="0" />
      <LineId Id="7338" Count="0" />
      <LineId Id="7325" Count="0" />
      <LineId Id="7327" Count="0" />
      <LineId Id="7123" Count="0" />
      <LineId Id="7515" Count="1" />
      <LineId Id="7124" Count="16" />
      <LineId Id="11015" Count="0" />
      <LineId Id="8070" Count="0" />
      <LineId Id="7798" Count="3" />
      <LineId Id="8069" Count="0" />
      <LineId Id="10634" Count="0" />
      <LineId Id="8471" Count="0" />
      <LineId Id="8470" Count="0" />
      <LineId Id="8477" Count="2" />
      <LineId Id="7145" Count="1" />
      <LineId Id="7791" Count="0" />
      <LineId Id="7147" Count="11" />
      <LineId Id="7792" Count="0" />
      <LineId Id="8656" Count="0" />
      <LineId Id="8655" Count="0" />
      <LineId Id="8725" Count="0" />
      <LineId Id="8737" Count="3" />
      <LineId Id="8744" Count="0" />
      <LineId Id="8742" Count="0" />
      <LineId Id="8741" Count="0" />
      <LineId Id="8733" Count="1" />
      <LineId Id="7793" Count="0" />
      <LineId Id="7160" Count="5" />
      <LineId Id="8682" Count="5" />
      <LineId Id="7172" Count="4" />
      <LineId Id="8711" Count="0" />
      <LineId Id="8713" Count="6" />
      <LineId Id="8712" Count="0" />
      <LineId Id="8720" Count="0" />
      <LineId Id="7177" Count="0" />
      <LineId Id="7179" Count="0" />
      <LineId Id="7187" Count="1" />
      <LineId Id="732" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.InvertRecipeSettings">
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="21" Count="1" />
      <LineId Id="27" Count="5" />
      <LineId Id="26" Count="0" />
      <LineId Id="33" Count="2" />
      <LineId Id="25" Count="0" />
      <LineId Id="37" Count="2" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.METH">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.METH_1">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.METH_2">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.METH_3">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.METH_4">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.SeqTestMotor">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.SeqTestOnce">
      <LineId Id="265" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="313" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="2" Count="2" />
      <LineId Id="159" Count="0" />
      <LineId Id="5" Count="11" />
      <LineId Id="19" Count="1" />
      <LineId Id="248" Count="1" />
      <LineId Id="268" Count="1" />
      <LineId Id="25" Count="9" />
      <LineId Id="295" Count="1" />
      <LineId Id="167" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="245" Count="0" />
      <LineId Id="44" Count="6" />
      <LineId Id="281" Count="1" />
      <LineId Id="280" Count="0" />
      <LineId Id="235" Count="1" />
      <LineId Id="226" Count="0" />
      <LineId Id="220" Count="0" />
      <LineId Id="421" Count="0" />
      <LineId Id="423" Count="1" />
      <LineId Id="422" Count="0" />
      <LineId Id="534" Count="1" />
      <LineId Id="420" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="434" Count="0" />
      <LineId Id="493" Count="0" />
      <LineId Id="441" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="537" Count="1" />
      <LineId Id="546" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="286" Count="0" />
      <LineId Id="314" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="288" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="446" Count="0" />
      <LineId Id="183" Count="4" />
      <LineId Id="192" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="403" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="271" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="532" Count="0" />
      <LineId Id="710" Count="0" />
      <LineId Id="784" Count="0" />
      <LineId Id="709" Count="0" />
      <LineId Id="675" Count="0" />
      <LineId Id="745" Count="3" />
      <LineId Id="751" Count="0" />
      <LineId Id="750" Count="0" />
      <LineId Id="785" Count="0" />
      <LineId Id="774" Count="0" />
      <LineId Id="773" Count="0" />
      <LineId Id="783" Count="0" />
      <LineId Id="778" Count="2" />
      <LineId Id="776" Count="0" />
      <LineId Id="782" Count="0" />
      <LineId Id="728" Count="0" />
      <LineId Id="118" Count="1" />
      <LineId Id="543" Count="0" />
      <LineId Id="541" Count="1" />
      <LineId Id="659" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="458" Count="0" />
      <LineId Id="123" Count="1" />
      <LineId Id="823" Count="0" />
      <LineId Id="566" Count="0" />
      <LineId Id="824" Count="0" />
      <LineId Id="638" Count="0" />
      <LineId Id="565" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="129" Count="1" />
      <LineId Id="548" Count="0" />
      <LineId Id="547" Count="0" />
      <LineId Id="550" Count="0" />
      <LineId Id="552" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="796" Count="1" />
      <LineId Id="810" Count="2" />
      <LineId Id="807" Count="0" />
      <LineId Id="801" Count="2" />
      <LineId Id="819" Count="0" />
      <LineId Id="822" Count="0" />
      <LineId Id="821" Count="0" />
      <LineId Id="804" Count="0" />
      <LineId Id="559" Count="0" />
      <LineId Id="558" Count="0" />
      <LineId Id="561" Count="1" />
      <LineId Id="564" Count="0" />
      <LineId Id="131" Count="20" />
      <LineId Id="519" Count="1" />
      <LineId Id="389" Count="0" />
      <LineId Id="154" Count="4" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="DMXTest.SeqTestOnceDC">
      <LineId Id="218" Count="120" />
      <LineId Id="435" Count="0" />
      <LineId Id="339" Count="5" />
      <LineId Id="436" Count="0" />
      <LineId Id="345" Count="0" />
      <LineId Id="433" Count="1" />
      <LineId Id="348" Count="4" />
      <LineId Id="358" Count="34" />
      <LineId Id="404" Count="28" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>